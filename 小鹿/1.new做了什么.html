<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
<script>


// function newFun(Fun, ...args) {

//   // 1. 创建一个空对象
//   let newObj = {}


//   // 2. 把空对象和构造函数通过原型链进行连接
//   newObj.__proto__ = Fun.prototype

//   // 3. 把构造函数的 this 绑定到新的空对象上
//   const result = Fun.apply(newObj, args)

//   console.log(result instanceof Object)

//   // 4. 根据构造函数返回的值的类型判断，如果是值类型，就返回对象，如果是引入用类型就返回引用类型
//   return result instanceof Object ? result : newObj

// }



// function Person(name) {
//   this.name = name

//   return {a: 1} // 构造函数 return 一个 引用类型时，new 构造函数 得到的就是引用类型值
//   return 1  // 构造函数 return 一个值（数字）类型时，得到的仍然是对象
// }

// Person.prototype.say = function() {
//   console.log('sany')
// }

// const p1 = newFun(Person, '章三')

// console.log(p1)



// 测试上述结论
function Person(name) {
  this.name = name

  this.say = function() {
    console.log('say')
  }
  // return 1 返回 Person 构造函数产生的对象
  // return { b: 'bb' } 返回 {b: 'bb'}
}


const pTest = new Person('aa')

console.log(pTest)







// 查看 Person 的 prototyp 和 实例的 __proto__
// function Person(name) {
//   this.name = name

//   this.say = function() {
//     console.log('say')
//   }
// }

// Person.prototype.hello = function() {
//   console.log('hello')
// }

// const p1 = new Person('aa')

// console.log(p1)

// console.log(Person.prototype)



  
</script>
</body>
</html>